复用：不是简单的复制代码拿来使用，而是使用人家写好的，调试好的代码，并且不能污染别人的源代码。  
实现的办法有两个：在自己的类中new一个要用的对象，进行组合（有一个）；继承原来的类

# 组合  
没有什么好说的，就是将对象需要放到我们的类里面。  

# 继承（关键字extends）  
我们的类除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object），创建派生类的对象时，它包含基类的子对象，在派生类的构造函数调用的时候就会自动调用基类的构造函数，创建一个基类子对象（基类有无参构造器，如果没有无参构造器的话就需要用super关键字显式的调用基类的带参构造函数）。  

# 委托  
介于继承与组合之间，将一个成员对象放在正在构建的类中（组合），同时在新类中公开来自成员对象的所有方法（继承）。被委托的类被实例化为对象放在新的类中，并且在新的类中通过同名的方法进行转发，提供接口，控制访问权限。  

组合和继承之间的选择  
组合：在新类中包含一个已有类的功能   
继承：使用一个现有类并开发出它的新版本  

继承中要用的一个重要的关键字protected  
对于其他类隐藏，允许派生类的成员访问（对于同一个包中的类也是可以访问的）  

[向上转型](./009多态.md)  
从一个更具体的类（派生类）转化为一个更一般的类（基类），所以向上转型永远是安全的（派生类对象也是基类类型，向上转型的时候只可能失去方法，不会增加方法，因此不会导致问题）。但是，向下转型的时候可能会导致问题（无法访问派生类的基类中没有的方法，java中每一次转型都会被检查，不对的话会抛出类型转换异常）。    

组合与继承  
实际中，我们用的更多的其实应该是组合，除非我们很明确的需要向上转型（比如使用多态）  



关键字final  
final：不能改变的  
数据：对于基本类型，初始化后这个值就不会再变了；对于非基本类型，使得引用恒定不变，一旦指向一个对象，就无法再修改指向其他对象，但是对象本身是可以修改的。  
空白final：在使用前必须被初始化，从而可以保证每个对象的final属性值不同，但是都是不可以改变  
final参数：不能修改参数指向的对象或者基本变量（匿名内部类使用较多[todo]）  
final方法：方法上锁，防止子类修改方法行为（以前还用来提高效率，将方法视为内嵌调用，减少方法调用开销【方法调用的时候，需要将参数压栈，跳转到方法所在代码，执行，跳回原来的地方，清理栈，返回值处理】）  

private方法其实都是final的，无法被子类重写。派生类种创建同名的，public，protected 或包访问权限的方法，只是在新建方法，没有重写效果。  
final类：无法被继承，设计意图就是不再需要改动或者不希望有子类。








